// ============================================
// CONTRATO DE LENDING BTCFi
// ============================================
// Este contrato permite a los usuarios depositar Bitcoin (wBTC) como colateral
// y pedir prestado contra ese colateral. Incluye liquidaciones automáticas.

// Chainlink Oracle Interface
use starknet::ContractAddress;

#[starknet::interface]
pub trait IChainlinkAggregator<TContractState> {
    fn latest_round_data(self: @TContractState) -> (u128, u128, u64, u64, u64);
    fn decimals(self: @TContractState) -> u8;
}

pub mod mocks;

// ============================================
// INTERFAZ PÚBLICA DEL CONTRATO
// ============================================
// Define todas las funciones que pueden ser llamadas externamente

#[starknet::interface]
pub trait IBTCLending<TContractState> {
    // Depositar wBTC como colateral
    // @param amount: Cantidad en wBTC (8 decimales, ej: 100_000_000 = 1 BTC)
    fn deposit_collateral(ref self: TContractState, amount: u256);

    // Pedir prestado contra el colateral
    // @param amount: Cantidad en USD a pedir prestado
    fn borrow(ref self: TContractState, amount: u256);

    // Liquidar a un usuario si su Health Factor < 100
    // @param user: Dirección del usuario a liquidar
    fn liquidate(ref self: TContractState, user: ContractAddress);

    // Calcular el Health Factor de un usuario
    // @return: HF × 100 (ej: 160 significa HF = 1.6)
    fn calculate_health_factor(self: @TContractState, user: ContractAddress) -> u256;

    // Obtener el colateral depositado por un usuario
    fn get_user_collateral(self: @TContractState, user: ContractAddress) -> u256;

    // Obtener la deuda de un usuario
    fn get_user_debt(self: @TContractState, user: ContractAddress) -> u256;

    // Retirar colateral depositado
    // @param amount: Cantidad de wBTC a retirar (8 decimales)
    fn withdraw_collateral(ref self: TContractState, amount: u256);

    // Pagar deuda
    // @param amount: Cantidad de deuda a pagar (en USD)
    fn repay(ref self: TContractState, amount: u256);

    // Obtener precio actual de BTC desde Pragma Oracle
    // @return: Precio de BTC en USD (13 decimales)
    fn get_btc_price(self: @TContractState) -> u256;

    // Actualizar precio del oráculo (solo para testing/fallback)
    fn set_oracle_price(ref self: TContractState, price: u256);
}

#[starknet::contract]
mod BTCLending {
    use openzeppelin::token::erc20::interface::{IERC20Dispatcher, IERC20DispatcherTrait};
    use starknet::storage::{
        Map, StorageMapReadAccess, StorageMapWriteAccess, StoragePointerReadAccess,
        StoragePointerWriteAccess,
    };
    use starknet::{ContractAddress, get_caller_address, get_contract_address};
    use super::{IChainlinkAggregatorDispatcher, IChainlinkAggregatorDispatcherTrait};

    // ============================================
    // STORAGE - Almacenamiento Permanente
    // ============================================
    // Todas estas variables se guardan en la blockchain

    #[storage]
    struct Storage {
        // Map: Diccionario que asocia dirección → cantidad
        user_collateral: Map<ContractAddress, u256>, // Colateral de cada usuario
        user_debt: Map<ContractAddress, u256>, // Deuda de cada usuario
        wbtc_token: ContractAddress, // Dirección del token wBTC
        liquidation_threshold: u256, // Umbral (8000 = 80%)
        chainlink_btc_usd: ContractAddress // Dirección del Chainlink BTC/USD Price Feed
    }

    // ============================================
    // CONSTRUCTOR
    // ============================================
    // Se ejecuta UNA SOLA VEZ al desplegar el contrato

    #[constructor]
    fn constructor(
        ref self: ContractState,
        wbtc_token: ContractAddress, // Dirección del token wBTC
        liquidation_threshold: u256, // Ej: 8000 = 80%
        chainlink_btc_usd: ContractAddress // Dirección del Chainlink BTC/USD Feed
    ) {
        self.wbtc_token.write(wbtc_token);
        self.liquidation_threshold.write(liquidation_threshold);
        self.chainlink_btc_usd.write(chainlink_btc_usd);
    }

    #[abi(embed_v0)]
    impl BTCLendingImpl of super::IBTCLending<ContractState> {
        // ============================================
        // DEPOSITAR COLATERAL
        // ============================================
        fn deposit_collateral(ref self: ContractState, amount: u256) {
            // 1. Obtener quién está llamando la función
            let caller = get_caller_address();
            let contract_vault = get_contract_address();

            // 2. Transferir wBTC del usuario a este contrato
            // NOTA: El usuario debe haber hecho approve() antes
            let token_dispatcher = IERC20Dispatcher { contract_address: self.wbtc_token.read() };
            token_dispatcher.transfer_from(caller, contract_vault, amount);

            // 3. Actualizar el colateral del usuario en el storage
            let current_collateral = self.user_collateral.read(caller);
            self.user_collateral.write(caller, current_collateral + amount);
        }

        // ============================================
        // PEDIR PRESTADO
        // ============================================
        fn borrow(ref self: ContractState, amount: u256) {
            let caller = get_caller_address();

            // 1. Actualizar la deuda del usuario
            let current_debt = self.user_debt.read(caller);
            self.user_debt.write(caller, current_debt + amount);

            // 2. Verificar que el Health Factor sea >= 100
            // Si es menor, la transacción se revierte
            let health_factor = self.calculate_health_factor(caller);
            assert(health_factor >= 100, 'Health factor too low');
            // NOTA: En producción, aquí transferirías stablecoins al usuario
        // Por ahora solo actualizamos la deuda
        }

        // ============================================
        // LIQUIDAR
        // ============================================
        fn liquidate(ref self: ContractState, user: ContractAddress) {
            // 1. Verificar que el usuario esté liquidable (HF < 100)
            let health_factor = self.calculate_health_factor(user);
            assert(health_factor < 100, 'User is healthy');

            // 2. Obtener datos del usuario
            let _debt = self.user_debt.read(user);
            let collateral = self.user_collateral.read(user);

            let liquidator = get_caller_address();

            // 3. Transferir el colateral al liquidador
            let token_dispatcher = IERC20Dispatcher { contract_address: self.wbtc_token.read() };
            token_dispatcher.transfer(liquidator, collateral);

            // 4. Limpiar la posición del usuario
            self.user_debt.write(user, 0);
            self.user_collateral.write(user, 0);
        }

        // ============================================
        // CALCULAR HEALTH FACTOR
        // ============================================
        // Fórmula: (Colateral en USD × 80% × 100) / Deuda

        fn calculate_health_factor(self: @ContractState, user: ContractAddress) -> u256 {
            let collateral = self.user_collateral.read(user);
            let debt = self.user_debt.read(user);

            // Si no hay deuda, retornar un número muy alto (infinito)
            if debt == 0 {
                return 999_999_999;
            }

            // 1. Obtener precio de BTC desde oracle
            let btc_price = self.get_btc_price();

            // 2. Convertir colateral BTC a USD
            // Dividimos entre 10^8 porque BTC tiene 8 decimales
            let collateral_value_usd = (collateral * btc_price) / 100_000_000;

            // 3. Aplicar umbral de liquidación (80%)
            let collateral_adjusted = (collateral_value_usd * self.liquidation_threshold.read())
                / 10000;

            // 4. Calcular HF (multiplicamos por 100 para evitar decimales)
            (collateral_adjusted * 100) / debt
        }

        // ============================================
        // GETTERS - Funciones de Solo Lectura
        // ============================================

        fn get_user_collateral(self: @ContractState, user: ContractAddress) -> u256 {
            self.user_collateral.read(user)
        }

        fn get_user_debt(self: @ContractState, user: ContractAddress) -> u256 {
            self.user_debt.read(user)
        }

        // ============================================
        // ACTUALIZAR PRECIO (Solo para Testing)
        // ============================================

        // ============================================
        // RETIRAR COLATERAL
        // ============================================
        fn withdraw_collateral(ref self: ContractState, amount: u256) {
            let caller = get_caller_address();

            // 1. Verificar que el monto sea positivo
            assert(amount > 0, 'Amount must be positive');

            // 2. Verificar que el usuario tenga suficiente colateral
            let current_collateral = self.user_collateral.read(caller);
            assert(current_collateral >= amount, 'Insufficient collateral');

            // 3. Actualizar el colateral ANTES de verificar HF
            self.user_collateral.write(caller, current_collateral - amount);

            // 4. Verificar que el Health Factor siga siendo >= 100
            // Solo si el usuario tiene deuda
            let debt = self.user_debt.read(caller);
            if debt > 0 {
                let health_factor = self.calculate_health_factor(caller);
                assert(health_factor >= 100, 'Health factor too low');
            }

            // 5. Transferir wBTC del contrato al usuario
            let token_dispatcher = IERC20Dispatcher { contract_address: self.wbtc_token.read() };
            token_dispatcher.transfer(caller, amount);
        }

        // ============================================
        // PAGAR DEUDA
        // ============================================
        fn repay(ref self: ContractState, amount: u256) {
            let caller = get_caller_address();

            // 1. Verificar que el monto sea positivo
            assert(amount > 0, 'Amount must be positive');

            // 2. Obtener la deuda actual
            let current_debt = self.user_debt.read(caller);
            assert(current_debt > 0, 'No debt to repay');

            // 3. Calcular cuánto pagar (no puede pagar más de la deuda)
            let repay_amount = if amount > current_debt {
                current_debt
            } else {
                amount
            };

            // 4. Actualizar la deuda
            self.user_debt.write(caller, current_debt - repay_amount);
            // NOTA: En producción aquí transferirías stablecoins del usuario al contrato
        // Por ahora solo actualizamos la deuda en storage
        }

        // ============================================
        // OBTENER PRECIO DE BTC DESDE CHAINLINK ORACLE
        // ============================================
        // Lee el precio actual de BTC/USD desde Chainlink Data Feed
        // Valida que el precio sea reciente (< 5 minutos)

        fn get_btc_price(self: @ContractState) -> u256 {
            let chainlink_feed = self.chainlink_btc_usd.read();

            // Verificar que el feed esté configurado
            let zero_address: ContractAddress = starknet::contract_address_const::<0>();
            assert(chainlink_feed != zero_address, 'Chainlink feed not configured');

            // Llamar a Chainlink para obtener el precio
            let aggregator = IChainlinkAggregatorDispatcher { contract_address: chainlink_feed };
            let (round_id, answer, _block_num, _started_at, updated_at) = aggregator
                .latest_round_data();

            // Validar que el precio sea válido
            assert(answer > 0, 'Invalid price from Chainlink');
            assert(round_id > 0, 'Invalid round data');

            // Validar que el precio no sea muy antiguo (5 minutos = 300 segundos)
            let current_time = starknet::get_block_timestamp();
            let time_diff = current_time - updated_at;
            assert(time_diff < 300, 'Price data is stale');

            // Convertir u128 a u256 y retornar
            // El precio ya viene con 8 decimales desde Chainlink
            answer.into()
        }

        // ============================================
        // ACTUALIZAR PRECIO DEL ORÁCULO (DEPRECATED)
        // ============================================
        // Esta función ya no se usa con Chainlink
        // Se mantiene por compatibilidad con la interfaz

        fn set_oracle_price(
            ref self: ContractState, price: u256,
        ) { // No hace nada - Chainlink proporciona precios automáticamente
        // Esta función se mantiene solo para compatibilidad con la interfaz IBTCLending
        }
    }
}
